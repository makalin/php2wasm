#!/bin/bash
#
# php2wasm pack utility
# Packages PHP applications into single WebAssembly modules
#

set -e

# Default values
INPUT_DIR=""
OUTPUT_FILE=""
INCLUDE_COMPOSER=false
VERBOSE=false
HELP=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Show usage
show_usage() {
    cat << EOF
php2wasm pack utility

Usage: $0 [OPTIONS] <input_dir> -o <output_file>

Options:
    -o, --output FILE        Output WebAssembly file
    -c, --composer           Include Composer dependencies
    -v, --verbose            Verbose output
    -h, --help               Show this help message

Examples:
    $0 ./src -o app.wasm
    $0 ./app --composer -o app.wasm
    $0 ./project -o dist/project.wasm --verbose

Description:
    Packages a PHP application directory into a single WebAssembly module.
    The resulting .wasm file can be executed with wasmtime or wasmer.

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -c|--composer)
                INCLUDE_COMPOSER=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                HELP=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                if [[ -z "$INPUT_DIR" ]]; then
                    INPUT_DIR="$1"
                else
                    print_error "Multiple input directories specified"
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# Validate arguments
validate_args() {
    if [[ "$HELP" == true ]]; then
        show_usage
        exit 0
    fi

    if [[ -z "$INPUT_DIR" ]]; then
        print_error "Input directory is required"
        show_usage
        exit 1
    fi

    if [[ -z "$OUTPUT_FILE" ]]; then
        print_error "Output file is required"
        show_usage
        exit 1
    fi

    if [[ ! -d "$INPUT_DIR" ]]; then
        print_error "Input directory does not exist: $INPUT_DIR"
        exit 1
    fi

    # Create output directory if it doesn't exist
    OUTPUT_DIR=$(dirname "$OUTPUT_FILE")
    if [[ ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
        print_info "Created output directory: $OUTPUT_DIR"
    fi
}

# Check dependencies
check_dependencies() {
    local missing_deps=()

    if ! command -v wasm-ld &> /dev/null; then
        missing_deps+=("wasm-ld")
    fi

    if ! command -v clang &> /dev/null; then
        missing_deps+=("clang")
    fi

    if [[ "$INCLUDE_COMPOSER" == true ]] && ! command -v composer &> /dev/null; then
        missing_deps+=("composer")
    fi

    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_error "Missing dependencies: ${missing_deps[*]}"
        print_info "Please install the missing dependencies and try again"
        exit 1
    fi
}

# Create temporary directory
create_temp_dir() {
    TEMP_DIR=$(mktemp -d)
    print_info "Created temporary directory: $TEMP_DIR"
}

# Cleanup temporary directory
cleanup_temp_dir() {
    if [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
        print_info "Cleaned up temporary directory"
    fi
}

# Copy PHP files
copy_php_files() {
    print_info "Copying PHP files from $INPUT_DIR"
    
    # Find all PHP files
    find "$INPUT_DIR" -name "*.php" -type f | while read -r file; do
        # Calculate relative path
        rel_path="${file#$INPUT_DIR/}"
        
        # Create directory structure in temp
        temp_file="$TEMP_DIR/$rel_path"
        temp_dir=$(dirname "$temp_file")
        mkdir -p "$temp_dir"
        
        # Copy file
        cp "$file" "$temp_file"
        
        if [[ "$VERBOSE" == true ]]; then
            print_info "  Copied: $rel_path"
        fi
    done
}

# Install Composer dependencies
install_composer_deps() {
    if [[ "$INCLUDE_COMPOSER" == false ]]; then
        return
    fi

    print_info "Installing Composer dependencies"
    
    if [[ -f "$INPUT_DIR/composer.json" ]]; then
        cd "$INPUT_DIR"
        composer install --no-dev --optimize-autoloader --quiet
        print_success "Composer dependencies installed"
        
        # Copy vendor directory
        if [[ -d "vendor" ]]; then
            cp -r vendor "$TEMP_DIR/"
            print_info "Copied vendor directory"
        fi
    else
        print_warning "No composer.json found, skipping Composer dependencies"
    fi
}

# Create VFS (Virtual File System) header
create_vfs_header() {
    print_info "Creating VFS header"
    
    local vfs_header="$TEMP_DIR/vfs.h"
    cat > "$vfs_header" << 'EOF'
#ifndef VFS_H
#define VFS_H

#include <stdint.h>
#include <stddef.h>

typedef struct {
    const char* path;
    const uint8_t* data;
    size_t size;
} vfs_file_t;

typedef struct {
    const char* name;
    const vfs_file_t* files;
    size_t file_count;
} vfs_directory_t;

extern const vfs_directory_t vfs_root;

#endif // VFS_H
EOF

    print_success "VFS header created"
}

# Generate VFS data
generate_vfs_data() {
    print_info "Generating VFS data"
    
    local vfs_data="$TEMP_DIR/vfs_data.c"
    local vfs_header="$TEMP_DIR/vfs.h"
    
    echo '#include "vfs.h"' > "$vfs_data"
    echo '' >> "$vfs_data"
    
    # Generate file data
    echo 'static const uint8_t file_data[] = {' >> "$vfs_data"
    
    local file_count=0
    local offset=0
    local file_offsets=()
    local file_sizes=()
    local file_paths=()
    
    # Process all files
    find "$TEMP_DIR" -type f ! -name "*.c" ! -name "*.h" | while read -r file; do
        local rel_path="${file#$TEMP_DIR/}"
        local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        
        file_paths+=("$rel_path")
        file_sizes+=($file_size)
        file_offsets+=($offset)
        
        # Add file data
        if [[ $file_size -gt 0 ]]; then
            xxd -i "$file" | sed 's/^/    /' | sed 's/$/,/' >> "$vfs_data"
        fi
        
        offset=$((offset + file_size))
        file_count=$((file_count + 1))
    done
    
    echo '};' >> "$vfs_data"
    echo '' >> "$vfs_data"
    
    # Generate file table
    echo "static const vfs_file_t vfs_files[] = {" >> "$vfs_data"
    
    for ((i=0; i<file_count; i++)); do
        echo "    {\"${file_paths[i]}\", file_data + ${file_offsets[i]}, ${file_sizes[i]}}," >> "$vfs_data"
    done
    
    echo '};' >> "$vfs_data"
    echo '' >> "$vfs_data"
    
    # Generate root directory
    echo "const vfs_directory_t vfs_root = {" >> "$vfs_data"
    echo '    "/", vfs_files, '$file_count >> "$vfs_data"
    echo '};' >> "$vfs_data"
    
    print_success "VFS data generated with $file_count files"
}

# Compile WebAssembly module
compile_wasm() {
    print_info "Compiling WebAssembly module"
    
    # This is a simplified compilation process
    # In a real implementation, this would use the full PHP engine compilation
    
    local source_files=(
        "$TEMP_DIR/vfs_data.c"
        # Add other source files as needed
    )
    
    # Compile to WebAssembly
    clang -target wasm32-wasi \
          -nostdlib \
          -Wl,--no-entry \
          -Wl,--export-dynamic \
          -Wl,--allow-undefined \
          -o "$OUTPUT_FILE" \
          "${source_files[@]}" \
          2>/dev/null || {
        print_error "Compilation failed"
        return 1
    }
    
    print_success "WebAssembly module compiled: $OUTPUT_FILE"
}

# Show package info
show_package_info() {
    local file_size=$(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null || echo 0)
    local file_size_mb=$((file_size / 1024 / 1024))
    
    print_success "Package created successfully!"
    echo "  Output file: $OUTPUT_FILE"
    echo "  Size: ${file_size_mb}MB"
    echo "  Input directory: $INPUT_DIR"
    echo "  Composer deps: $INCLUDE_COMPOSER"
    
    echo ""
    print_info "To run the packaged application:"
    echo "  wasmtime run --dir=. $OUTPUT_FILE -- /path/to/entry.php"
    echo "  wasmer run --dir=. $OUTPUT_FILE -- /path/to/entry.php"
}

# Main function
main() {
    # Set up cleanup trap
    trap cleanup_temp_dir EXIT
    
    # Parse and validate arguments
    parse_args "$@"
    validate_args
    
    # Check dependencies
    check_dependencies
    
    # Create temporary directory
    create_temp_dir
    
    # Copy PHP files
    copy_php_files
    
    # Install Composer dependencies if requested
    install_composer_deps
    
    # Create VFS
    create_vfs_header
    generate_vfs_data
    
    # Compile WebAssembly module
    compile_wasm
    
    # Show package info
    show_package_info
}

# Run main function
main "$@"
